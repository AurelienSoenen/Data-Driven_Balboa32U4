clear; close all; clc;
%% 1/ Consider the following linear model describing a chemical reactor and obtained with unitary sample time.
% Dimension of A : n x n
A_c = [0 0 1 0; 
       0 0 0 1; 
       0 -69.4 0 0; 
       0  150 0 0];

% Dimension of B : n x m
B_c = [0; 0; 273; -130];

% Parameters
n = size(A_c,2);          
m = size(B_c,2);

Ts = 0.01; % Example: 10ms sampling time -> 100H
% Discretize the system
sys_c = ss(A_c,B_c,[1 0 0 0],0);
sys_d = c2d(sys_c, Ts);
A = sys_d.A;
B = sys_d.B;

% Assigment of the set 
% Define the settling time (in seconds)
t_s = 1;
bessel_4var1 = (1 / t_s) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
t_s = 0.6;
bessel_4var06 = (1 / t_s) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
p_4var_bessel1 = exp(bessel_4var1 * Ts);
p_4var_bessel06 = exp(bessel_4var06 * Ts);

% Model-Based Pole-placement methods
% The place.m function requires the Control System Toolbox.
K_bessel1_theory = place(A, B, p_4var_bessel1);
K_bessel06_theory = place(A, B, p_4var_bessel06);
K_MB = K_bessel1_theory;
 
% Arrays to store eigenvalue differences
eig_diff1_values = [];
eig_diff2_values = [];

rng(30);
T = 100;
% Historical data (u,x) is generated by simulating the open loop system
x = zeros(n, T); % Dimension of x : n x T
u = zeros(m, T); % Gaussian noise and Dimension of u : m x T
% Simulate the system for T time steps
for t = 1:T-1
    u(:,t) = - K_bessel06_theory * x(:,t) + randn(m,1)*0.5;
    rdm_state_measurement = [randn(m,1)/1000; randn(m,1)/1000; randn(m,1)/1000; randn(m,1)/1000];
    x(:,t+1) = A * x(:,t) + B * u(:,t) + rdm_state_measurement; % Give same gain with Bessel or ITAE
end
poledifs = (0.1:0.1:1.2);
% Loop over T values from 1 to 256 (doubling each iteration)
for poledif = poledifs
    % Feedback gain after perturbation
    U_0 = u(:,1:T-1); % Dimension of U_0 : m x T-1
    X_0 = x(:,1:T-1); % Dimension of X_0 : n x T-1
    X_1 = x(:,2:T); % Dimension of X_1 : n x T-1

    M_rdm = ones(T-1,n);

    t_s = poledif;
    besselts = (1 / t_s) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
    poles = exp(besselts * Ts);

    rdmPoles = poles;
    %rdmPoles = [1 -1 1j -1j]-[0.01 -0.01 0.01 -0.01]*poledif;

    K_MB = place(A, B, poles);

    for i = 1:n
        M_rdm(:,i) = fsolve(@(m_i) (X_1 - rdmPoles(i)*X_0)*m_i, M_rdm(:,i));
    end

    K_directDD = - U_0 * M_rdm * pinv(X_0 * M_rdm);
    eig1 = eig(A - B * K_directDD);
    eig_diff1 = mean(abs(abs(K_directDD - K_MB)./abs(K_MB)));
    eig_diff1_values = [eig_diff1_values, eig1];

    % Linear Regression for A and B

    BA = X_1 * pinv([X_0; U_0]);
    A_OL = BA(:, 1:4); % This assumes A is in the second column of the combined matrix
    B_OL = BA(:, 5); % This assumes B is in the first column of the combined matrix
    
    K_indirectDD = place(A_OL, B_OL, rdmPoles);
    eig2 = eig(A - B * K_indirectDD);
    eig_diff2 = mean(abs(abs(K_indirectDD - K_MB)./-K_MB));
    eig_diff2_values = [eig_diff2_values, eig2];

    
end

folderName = 'DataForPlot';
if ~exist(folderName, 'dir')
    mkdir(folderName);
end

% Prepare the data to be saved
x = poledifs;
y1 = eig_diff1_values;
y2 = eig_diff2_values;
data = [x' y1' y2'];

% Write to CSV
file = 'WithExcitementPolesEvoPlot';
csvwrite(fullfile(folderName, sprintf('%s.csv', file)), data);

% Optionally, include headers using fprintf
fileID = fopen(fullfile(folderName, sprintf('%s.csv', file)), 'w');
fprintf(fileID, 'x,p11,p12,p13,p14,p21,p22,p23,p24\n');
fclose(fileID);
dlmwrite(fullfile(folderName, sprintf('%s.csv', file)), data, '-append');

