clear; close all; clc;
%% 1/ Consider the following linear model describing a chemical reactor and obtained with unitary sample time.
% Dimension of A : n x n
A_c = [0 0 1 0; 
       0 0 0 1; 
       0 -69.4 0 0; 
       0  150 0 0];

% Dimension of B : n x m
B_c = [0; 0; 273; -130];


% Parameters
n = size(A_c,2);          
m = size(B_c,2);

Ts = 0.01; % Example: 10ms sampling time -> 100H
% Discretize the system
sys_c = ss(A_c,B_c,[1 0 0 0],0);
sys_d = c2d(sys_c, Ts);
A = sys_d.A;
B = sys_d.B;

% Assigment of the set 
% Define the settling time (in seconds)
t_s = 1;
itae_4var = (1 / t_s) * [-4.236 + 12.617i, -4.236 - 12.617i, -6.254 + 4.139i, -6.254 - 4.139i];
bessel_4var = (1 / t_s) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
p_4var_itae = exp(itae_4var * Ts);
p_4var_bessel = exp(bessel_4var * Ts);

% Model-Based Pole-placement methods
% The place.m function requires the Control System Toolbox.
K_itae_theory = place(A, B, p_4var_itae);
K_bessel_theory = place(A, B, p_4var_bessel);
 
%% 2/ The system is unstable and the open-loop eigenvalues are:

%% 3/ Therefore, we move two of the unstable modes (7.0162;1.0798) into the unitary circle, keeping the original stable modes (0.0002;0.0065)
% Set random seed reproducibility
rng(50);

% Historical data (u,x) is generated by simulating the open loop system
%                       x(t+1) = Ax(t) + Bu(t)          (1) 
% for T = 10 time steps by applying Gaussian noise as the input signal (u)
% and starting from zero initial conditions (x(1) = 0)
T = 1000;

% Dimension of x : n x T
x = zeros(n,T);

% Gaussian noise and Dimension of u : m x T
% (i.i.d = independent and identically distributed)
u = zeros(m,T);     
% Only dependant of initial poles implemented
for t=1:1:T-1
    u(:,t) = - K_itae_theory*x(:,t);
    rdm_state_measurement = [randn(m,1)/100; randn(m,1)/100; randn(m,1)/100; randn(m,1)/100];
    x(:,t+1) = A * x(:,t) + B * u(:,t) + rdm_state_measurement; % Give same gain with Bessel or ITAE
end

%% Feedback gain after perturbation
% It will be useful to consider the following representation of the data
% Dimension of U_0 : m x T-1
U_0 = u(:,1:T-1);
% Dimension of X_0 : n x T-1
X_0 = x(:,1:T-1);
% Dimension of X_1 : n x T-1
X_1 = x(:,2:T);

% Dimension of M : T-1 x n
M_itae = ones(T-1,n);
M_bessel = ones(T-1,n);

rdmPoles = [0.9, 0.1, -0.9, -0.1];
rdmPoles = p_4var_bessel;

for i=1:n
    M_rdm(:,i) = fsolve( @(m_i) (X_1 - rdmPoles(i)*X_0)*m_i, M_bessel(:,i) );
end

% Dimension of K : m x n
% Additional info: B = pinv(A) returns the Moore_Penrose Pseudoinverse of matrix A.
% For any M that statisfies (7), the feedback gain obtained as 
K_directDD = - U_0 * M_rdm * pinv( X_0*M_rdm )

%% 4 Approach Linear Regresssion A and B
BA = X_1 * pinv([X_0; U_0]);
A_OL = BA(:, 1:4); % This assumes A is in the second column of the combined matrix
B_OL = BA(:, 5); % This assumes B is in the first column of the combined matrix

K_indirectDD =  place(A_OL, B_OL, rdmPoles)

% Compute the eigenvalues
eig1 = eig(A - B * K_directDD);
eig2 = eig(A - B * K_indirectDD);
eig = p_4var_itae;

% Calculate the differences between corresponding eigenvalues
eig_diff = norm(eig1 - eig)
eig_diff = norm(eig2 - eig)



