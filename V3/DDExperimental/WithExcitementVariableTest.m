clear; close all; clc;
%% 1/ Consider the following linear model describing a chemical reactor and obtained with unitary sample time.
% Dimension of A : n x n
A_c = [0 0 1 0; 
       0 0 0 1; 
       0 -69.4 0 0; 
       0  150 0 0];

% Dimension of B : n x m
B_c = [0; 0; 273; -130];

% Parameters
n = size(A_c,2);          
m = size(B_c,2);

Ts = 0.01; % Example: 10ms sampling time -> 100H
% Discretize the system
sys_c = ss(A_c,B_c,[1 0 0 0],0);
sys_d = c2d(sys_c, Ts);
A = sys_d.A;
B = sys_d.B;

% Assigment of the set 
% Define the settling time (in seconds)
t_s = 1;
itae_4var = (1 / t_s) * [-4.236 + 12.617i, -4.236 - 12.617i, -6.254 + 4.139i, -6.254 - 4.139i];
bessel_4var = (1 / t_s) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
p_4var_itae = exp(itae_4var * Ts);
p_4var_bessel = exp(bessel_4var * Ts);

% Model-Based Pole-placement methods
% The place.m function requires the Control System Toolbox.
K_itae_theory = place(A, B, p_4var_itae);
K_bessel_theory = place(A, B, p_4var_bessel);
 
% Arrays to store eigenvalue differences
eig_diff1_values = [];
eig_diff2_values = [];
min_eig_diff1 = inf;
min_eig_diff2 = inf;
best_K_directDD = [];
best_K_indirectDD = [];

T_values = (50:10:200); % Generates values 10 to 80
rng(20);
T = 600;
% Historical data (u,x) is generated by simulating the open loop system
x = zeros(n, T); % Dimension of x : n x T
u = zeros(m, T); % Gaussian noise and Dimension of u : m x T

% Simulate the system for T time steps
for t = 1:T-1
    u(:,t) = - K_itae_theory * x(:,t) + randn(m,1)*0.5;
    noise = 0.03;
    rdm_state_measurement = [randn(m,1)*noise; randn(m,1)*noise; randn(m,1)*noise; randn(m,1)*noise];
    x(:,t+1) = A * x(:,t) + B * u(:,t) + rdm_state_measurement; % Give same gain with Bessel or ITAE
end
% Kalman filter parameters
Q = eye(n) * 0.03^2;  % Process noise covariance
R = eye(n) * 0.03^2;  % Measurement noise covariance
P = eye(n);  % Initial estimation covariance
x_hat = zeros(n, 1);  % Initial state estimate

% Arrays to store the filtered estimates
x_est = zeros(n, length(u));

% Kalman filter implementation
for t = 1:length(u)
    % Prediction step
    x_pred = A * x_hat + B * u(:, t);
    P_pred = A * P * A' + Q;

    % Measurement update step
    y = x(:, t);  % Measured state
    S = P_pred + R;
    K = P_pred / S;
    x_hat = x_pred + K * (y - x_pred);
    P = (eye(n) - K) * P_pred;

    % Store estimates
    x_est(:, t) = x_hat;
end
% Loop over T values
for T = T_values
    % Feedback gain after perturbation
    U_0 = u(:,1:T-1); % Dimension of U_0 : m x T-1
    X_0 = x(:,1:T-1); % Dimension of X_0 : n x T-1
    X_1 = x(:,2:T); % Dimension of X_1 : n x T-1

    M_rdm = ones(T-1,n);

    rdmPoles = p_4var_bessel;

    for i = 1:n
        M_rdm(:,i) = fsolve(@(m_i) (X_1 - rdmPoles(i)*X_0)*m_i, M_rdm(:,i));
    end

    K_directDD = - U_0 * M_rdm * pinv(X_0 * M_rdm);
    eig1 = eig(A - B * K_directDD);
    eig_diff1 = norm(eig1 - p_4var_bessel');
    %eig_diff1 = abs(eig1' - p_4var_bessel)*abs(p_4var_bessel')/4;
    %eig_diff1 = norm(K_directDD - K_bessel_theory);
    eig_diff1 = mean(abs(abs(K_directDD - K_bessel_theory)./abs(K_bessel_theory)));
    eig_diff1_values = [eig_diff1_values, eig_diff1];
    if eig_diff1 < min_eig_diff1
        min_eig_diff1 = eig_diff1;
        best_K_directDD = K_directDD;
    end

    % Linear Regression for A and B
    if T > 5
        BA = X_1 * pinv([X_0; U_0]);
        A_OL = BA(:, 1:4); % This assumes A is in the second column of the combined matrix
        B_OL = BA(:, 5); % This assumes B is in the first column of the combined matrix
        
        K_indirectDD = place(A_OL, B_OL, rdmPoles);
        eig2 = eig(A - B * K_indirectDD);
        eig_diff2 = norm(eig2 - p_4var_bessel');
        %eig_diff2 = abs(eig2' - p_4var_bessel)*abs(p_4var_bessel')/4;
        %eig_diff2 = norm(K_indirectDD - K_bessel_theory);
        eig_diff2 = mean(abs(abs(K_indirectDD - K_bessel_theory)./-K_bessel_theory));
        eig_diff2_values = [eig_diff2_values, eig_diff2];
        if eig_diff2 < min_eig_diff2
            min_eig_diff2 = eig_diff2;
            best_K_indirectDD = K_indirectDD;
        end
    end
end
disp(real(K_bessel_theory));
%% Display the values of K_directDD and K_indirectDD for the lowest eigenvalue differences
disp('K_directDD with lowest eig_diff1:');
disp(real(best_K_directDD));
disp(min_eig_diff1);
disp('K_indirectDD with lowest eig_diff2:');
disp(best_K_indirectDD);
disp( min_eig_diff2);

% Plot the eigenvalue differences
figure;

x0=200;
y0=200;
width=500;
height=400;
set(gcf,'position',[x0,y0,width,height])

% Plotting the eigenvalue differences
plot(T_values/100, eig_diff1_values, 'k-o', 'LineWidth', 1.25, 'MarkerFaceColor', 'k');
hold on;
plot(T_values(T_values>5)/100, eig_diff2_values, 'k--o', 'LineWidth', 1.25, 'MarkerFaceColor', 'w');

% Adding labels
xlabel('t[s]');
ylabel('MRE [-]');

% Adding title and grid
%title('Eigenvalue Differences vs T');
grid on;

% Adding legend
legend('K\_direct', 'K\_indirect', 'Location', 'northeast');

% Setting the axis limits if needed
%xlim([1 256]);
%ylim([0, max([eig_diff1_values, eig_diff2_values])]);

% Add additional plot customizations as needed to match the uploaded image
set(gca, 'FontSize', 12); % Adjust font size as per the image

hold off; % Release the plot hold

% Check if the folder 'plot' exists, if not, create it
folderName = 'plot';
if ~exist(folderName, 'dir')
    mkdir(folderName);
end

% Save the figure
saveas(gcf, fullfile(folderName, 'TimeExcitement.png'));
