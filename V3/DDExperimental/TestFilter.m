%% ------------------------------- Theorie ------------------------------- 
% Dimension of A : n x n
A_c = [0 0 1 0; 
       0 0 0 1; 
       0 -69.4 0 0; 
       0  150 0 0];

% Dimension of B : n x m
B_c = [0; 0; 273; -130];

% Parameters
n = size(A_c,2);          
m = size(B_c,2);

Ts = 0.01; % Example: 10ms sampling time -> 100H
% Discretize the system
sys_c = ss(A_c,B_c,[1 0 0 0],0);
sys_d = c2d(sys_c, Ts);
A = sys_d.A;
B = sys_d.B;

% Assigment of the set 
% Define the settling time (in seconds)
t_sITAE = 1;
t_sBessel = 1;
itae_4var = (1 / t_sITAE) * [-4.236 + 12.617i, -4.236 - 12.617i, -6.254 + 4.139i, -6.254 - 4.139i];
bessel_4var = (1 / t_sBessel) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
p_4var_itae = exp(itae_4var * Ts);
p_4var_bessel = exp(bessel_4var * Ts);

% With 5 poles
itae_5var = (1 / t_sITAE) * [-3.948 + 13.553i, -3.948 - 13.553i, -6.040 + 5.601i, -6.040 - 5.601i, -9.394];
bessel_5var = (1 / t_sBessel) * [-4.110 + 6.314i, -4.110 - 6.314i, -5.927 + 3.081i, -5.927 - 3.081i, -6.448];
p_5var_itae = exp(itae_5var * Ts);
p_5var_bessel = exp(bessel_5var * Ts);

% Model-Based Pole-placement methods
% The place.m function requires the Control System Toolbox.
K_itae_theory = place(A, B, p_4var_itae) - [0,0,0.19,0];
K_bessel_theory = place(A, B, p_4var_bessel) - [0,0,0.19,0];
K_theory = K_bessel_theory;

%% ------------------------------- LOAD DATA ------------------------------- 
 
% Arrays to store eigenvalue differences
eig_diff1_values = [];
eig_diff2_values = [];

Tmin = 500;
T_values = (100:100:1000);
rng(30);

% Measured data (u,x) is generated by simulating the open loop system
filePath = sprintf('../data/rdmITAE2.txt');
%filePath = sprintf('../data/ITAE/%.1f.txt', t_sITAE);
%filePath = sprintf('../data/DDBessel.txt');
data = readmatrix(filePath);
% Extract variables
phi = data(:, 2);
theta = data(:, 3);
phi_dot = data(:, 4);
theta_dot = data(:, 5);
u = [data(:, 6)]';  % Normalize input
ref = data(:, 7);  % reference variable
cst = sign(u);
x = [(phi-ref)'; theta'; phi_dot'; theta_dot'];
% Kalman filter parameters
Q = eye(n) * 0.03^2;  % Process noise covariance
R = eye(n) * 0.03^2;  % Measurement noise covariance
P = eye(n);  % Initial estimation covariance
x_hat = zeros(n, 1);  % Initial state estimate

% Arrays to store the filtered estimates
x_est = zeros(n, length(u));

% Kalman filter implementation
for t = 1:length(u)
    % Prediction step
    x_pred = A * x_hat + B * u(:, t);
    P_pred = A * P * A' + Q;

    % Measurement update step
    y = x(:, t);  % Measured state
    S = P_pred + R;
    K = P_pred / S;
    x_hat = x_pred + K * (y - x_pred);
    P = (eye(n) - K) * P_pred;

    % Store estimates
    x_est(:, t) = x_hat;
end


%% ------------------------------- Theorie ------------------------------- 
% Dimension of A : n x n
A_c = [0 0 1 0; 
       0 0 0 1; 
       0 -69.4 0 0; 
       0  150 0 0];

% Dimension of B : n x m
B_c = [0; 0; 273; -130];

% Parameters
n = size(A_c,2);          
m = size(B_c,2);

Ts = 0.01; % Example: 10ms sampling time -> 100H
% Discretize the system
sys_c = ss(A_c,B_c,[1 0 0 0],0);
sys_d = c2d(sys_c, Ts);
A = sys_d.A;
B = sys_d.B;

% Assigment of the set 
% Define the settling time (in seconds)
t_sITAE = 1;
t_sBessel = 1;
itae_4var = (1 / t_sITAE) * [-4.236 + 12.617i, -4.236 - 12.617i, -6.254 + 4.139i, -6.254 - 4.139i];
bessel_4var = (1 / t_sBessel) * [-4.016 + 5.072i, -4.016 - 5.072i, -5.528 + 1.655i, -5.528 - 1.655i];
p_4var_itae = exp(itae_4var * Ts);
p_4var_bessel = exp(bessel_4var * Ts);

% With 5 poles
itae_5var = (1 / t_sITAE) * [-3.948 + 13.553i, -3.948 - 13.553i, -6.040 + 5.601i, -6.040 - 5.601i, -9.394];
bessel_5var = (1 / t_sBessel) * [-4.110 + 6.314i, -4.110 - 6.314i, -5.927 + 3.081i, -5.927 - 3.081i, -6.448];
p_5var_itae = exp(itae_5var * Ts);
p_5var_bessel = exp(bessel_5var * Ts);

% Model-Based Pole-placement methods
% The place.m function requires the Control System Toolbox.
K_itae_theory = place(A, B, p_4var_itae) - [0,0,0.19,0];
K_bessel_theory = place(A, B, p_4var_bessel) - [0,0,0.19,0];
K_theory = K_bessel_theory;

%% ------------------------------- LOAD DATA ------------------------------- 
 
% Arrays to store eigenvalue differences
eig_diff1_values = [];
eig_diff2_values = [];

Tmin = 500;
T_values = (100:100:1000);
rng(30);

% Measured data (u,x) is generated by simulating the open loop system
filePath = sprintf('../data/rdmITAE2.txt');
%filePath = sprintf('../data/ITAE/%.1f.txt', t_sITAE);
%filePath = sprintf('../data/DDBessel.txt');
data = readmatrix(filePath);
% Extract variables
phi = data(:, 2);
theta = data(:, 3);
phi_dot = data(:, 4);
theta_dot = data(:, 5);
u = [data(:, 6)]';  % Normalize input
ref = data(:, 7);  % reference variable
cst = sign(u);
x = [(phi-ref)'; theta'; phi_dot'; theta_dot'];
% Kalman filter parameters
Q = eye(n) * 0.03^2;  % Process noise covariance
R = eye(n) * 0.03^2;  % Measurement noise covariance
P = eye(n);  % Initial estimation covariance
x_hat = zeros(n, 1);  % Initial state estimate

% Arrays to store the filtered estimates
x_est = zeros(n, length(u));

% Kalman filter implementation
for t = 1:length(u)
    % Prediction step
    x_pred = A * x_hat + B * u(:, t);
    P_pred = A * P * A' + Q;

    % Measurement update step
    y = x(:, t);  % Measured state
    S = P_pred + R;
    K = P_pred / S;
    x_hat = x_pred + K * (y - x_pred);
    P = (eye(n) - K) * P_pred;

    % Store estimates
    x_est(:, t) = x_hat;
end
% Plot results
figure;
for i = 1:n
    subplot(n, 1, i);
    plot(x(i, :), 'b', 'DisplayName', 'Measured State');
    hold on;
    plot(x_est(i, :), 'r', 'DisplayName', 'Estimated State');
    xlabel('Time Step');
    ylabel(['State ', num2str(i)]);
    legend;
end